<HTML>
<HEAD>
<meta charset="UTF-8">
<title>Crypto - corda</title>
<link rel="stylesheet" href="../../../style.css">

<meta name="docsearch:language" content="en">
<meta name="docsearch:version" content="4.3">
<meta name="docsearch:project" content="corda-enterprise">
</head>
<BODY>
<a href="../../index.html">corda</a>&nbsp;/&nbsp;<a href="../index.html">net.corda.core.crypto</a>&nbsp;/&nbsp;<a href="./index.html">Crypto</a><br/>
<br/>
<h1>Crypto</h1>
<code><span class="keyword">object </span><span class="identifier">Crypto</span></code>
<p>This object controls and provides the available and supported signature schemes for Corda.
Any implemented <a href="../-signature-scheme/index.html">SignatureScheme</a> should be strictly defined here.
However, only the schemes returned by {@link #listSupportedSignatureSchemes()} are supported.
Note that Corda currently supports the following signature schemes by their code names:</p>
<h3>Properties</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="-c-o-m-p-o-s-i-t-e_-k-e-y.html">COMPOSITE_KEY</a></p>
</td>
<td>
<code><span class="keyword">val </span><span class="identifier">COMPOSITE_KEY</span><span class="symbol">: </span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a></code>
<p>Corda <a href="../-composite-key/index.html">CompositeKey</a> signature type.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-d-e-f-a-u-l-t_-s-i-g-n-a-t-u-r-e_-s-c-h-e-m-e.html">DEFAULT_SIGNATURE_SCHEME</a></p>
</td>
<td>
<code><span class="keyword">val </span><span class="identifier">DEFAULT_SIGNATURE_SCHEME</span><span class="symbol">: </span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a></code>
<p>Our default signature scheme if no algorithm is specified (e.g. for key generation).</p>
</td>
</tr>
<tr>
<td>
<p><a href="-e-c-d-s-a_-s-e-c-p256-k1_-s-h-a256.html">ECDSA_SECP256K1_SHA256</a></p>
</td>
<td>
<code><span class="keyword">val </span><span class="identifier">ECDSA_SECP256K1_SHA256</span><span class="symbol">: </span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a></code>
<p>ECDSA signature scheme using the secp256k1 Koblitz curve and SHA256 for message hashing.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-e-c-d-s-a_-s-e-c-p256-r1_-s-h-a256.html">ECDSA_SECP256R1_SHA256</a></p>
</td>
<td>
<code><span class="keyword">val </span><span class="identifier">ECDSA_SECP256R1_SHA256</span><span class="symbol">: </span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a></code>
<p>ECDSA signature scheme using the secp256r1 (NIST P-256) curve and SHA256 for message hashing.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-e-d-d-s-a_-e-d25519_-s-h-a512.html">EDDSA_ED25519_SHA512</a></p>
</td>
<td>
<code><span class="keyword">val </span><span class="identifier">EDDSA_ED25519_SHA512</span><span class="symbol">: </span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a></code>
<p>EdDSA signature scheme using the ed25519 twisted Edwards curve and SHA512 for message hashing.
The actual algorithm is PureEdDSA Ed25519 as defined in https://tools.ietf.org/html/rfc8032
Not to be confused with the EdDSA variants, Ed25519ctx and Ed25519ph.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-r-s-a_-s-h-a256.html">RSA_SHA256</a></p>
</td>
<td>
<code><span class="keyword">val </span><span class="identifier">RSA_SHA256</span><span class="symbol">: </span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a></code>
<p>RSA PKCS#1 signature scheme using SHA256 for message hashing.
The actual algorithm id is 1.2.840.113549.1.1.1
Note: Recommended key size &gt;= 3072 bits.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-s-h-a512_256.html">SHA512_256</a></p>
</td>
<td>
<code><span class="keyword">val </span><span class="identifier">SHA512_256</span><span class="symbol">: </span><a href="http://www.bouncycastle.org/docs/docs1.5on/org/bouncycastle/asn1/DLSequence.html"><span class="identifier">DLSequence</span></a></code>
<p>DLSequence (ASN1Sequence) for SHA512 truncated to 256 bits, used in SPHINCS-256 signature scheme.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-s-p-h-i-n-c-s256_-s-h-a256.html">SPHINCS256_SHA256</a></p>
</td>
<td>
<code><span class="keyword">val </span><span class="identifier">SPHINCS256_SHA256</span><span class="symbol">: </span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a></code>
<p>SPHINCS-256 hash-based signature scheme using SHA512 for message hashing. It provides 128bit security against
post-quantum attackers at the cost of larger key nd signature sizes and loss of compatibility.</p>
</td>
</tr>
</tbody>
</table>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="decode-private-key.html">decodePrivateKey</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">decodePrivateKey</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$decodePrivateKey(kotlin.ByteArray)/encodedKey">encodedKey</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html"><span class="identifier">PrivateKey</span></a></code>
<p>Decode a PKCS8 encoded key to its <a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html">PrivateKey</a> object.
Use this method if the key type is a-priori unknown.</p>
<code><span class="keyword">fun </span><span class="identifier">decodePrivateKey</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$decodePrivateKey(kotlin.String, kotlin.ByteArray)/schemeCodeName">schemeCodeName</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$decodePrivateKey(kotlin.String, kotlin.ByteArray)/encodedKey">encodedKey</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html"><span class="identifier">PrivateKey</span></a></code><br/>
<code><span class="keyword">fun </span><span class="identifier">decodePrivateKey</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$decodePrivateKey(net.corda.core.crypto.SignatureScheme, kotlin.ByteArray)/signatureScheme">signatureScheme</span><span class="symbol">:</span>&nbsp;<a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$decodePrivateKey(net.corda.core.crypto.SignatureScheme, kotlin.ByteArray)/encodedKey">encodedKey</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html"><span class="identifier">PrivateKey</span></a></code>
<p>Decode a PKCS8 encoded key to its <a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html">PrivateKey</a> object based on the input scheme code name.
This should be used when the type key is known, e.g. during deserialisation or with key caches or key managers.</p>
</td>
</tr>
<tr>
<td>
<p><a href="decode-public-key.html">decodePublicKey</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">decodePublicKey</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$decodePublicKey(kotlin.ByteArray)/encodedKey">encodedKey</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a></code>
<p>Decode an X509 encoded key to its <a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html">PublicKey</a> object.
Use this method if the key type is a-priori unknown.</p>
<code><span class="keyword">fun </span><span class="identifier">decodePublicKey</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$decodePublicKey(kotlin.String, kotlin.ByteArray)/schemeCodeName">schemeCodeName</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$decodePublicKey(kotlin.String, kotlin.ByteArray)/encodedKey">encodedKey</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a></code><br/>
<code><span class="keyword">fun </span><span class="identifier">decodePublicKey</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$decodePublicKey(net.corda.core.crypto.SignatureScheme, kotlin.ByteArray)/signatureScheme">signatureScheme</span><span class="symbol">:</span>&nbsp;<a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$decodePublicKey(net.corda.core.crypto.SignatureScheme, kotlin.ByteArray)/encodedKey">encodedKey</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a></code>
<p>Decode an X509 encoded key to its <a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html">PrivateKey</a> object based on the input scheme code name.
This should be used when the type key is known, e.g. during deserialisation or with key caches or key managers.</p>
</td>
</tr>
<tr>
<td>
<p><a href="derive-key-pair.html">deriveKeyPair</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">deriveKeyPair</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$deriveKeyPair(net.corda.core.crypto.SignatureScheme, java.security.PrivateKey, kotlin.ByteArray)/signatureScheme">signatureScheme</span><span class="symbol">:</span>&nbsp;<a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$deriveKeyPair(net.corda.core.crypto.SignatureScheme, java.security.PrivateKey, kotlin.ByteArray)/privateKey">privateKey</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html"><span class="identifier">PrivateKey</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$deriveKeyPair(net.corda.core.crypto.SignatureScheme, java.security.PrivateKey, kotlin.ByteArray)/seed">seed</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/KeyPair.html"><span class="identifier">KeyPair</span></a></code>
<p>Deterministically generate/derive a <a href="http://docs.oracle.com/javase/8/docs/api/java/security/KeyPair.html">KeyPair</a> using an existing private key and a seed as inputs.
This operation is currently supported for ECDSA secp256r1 (NIST P-256), ECDSA secp256k1 and EdDSA ed25519.</p>
<code><span class="keyword">fun </span><span class="identifier">deriveKeyPair</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$deriveKeyPair(java.security.PrivateKey, kotlin.ByteArray)/privateKey">privateKey</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html"><span class="identifier">PrivateKey</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$deriveKeyPair(java.security.PrivateKey, kotlin.ByteArray)/seed">seed</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/KeyPair.html"><span class="identifier">KeyPair</span></a></code>
<p>Deterministically generate/derive a <a href="http://docs.oracle.com/javase/8/docs/api/java/security/KeyPair.html">KeyPair</a> using an existing private key and a seed as inputs.
Use this method if the <a href="../-signature-scheme/index.html">SignatureScheme</a> of the private key input is not known.</p>
</td>
</tr>
<tr>
<td>
<p><a href="derive-key-pair-from-entropy.html">deriveKeyPairFromEntropy</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">deriveKeyPairFromEntropy</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$deriveKeyPairFromEntropy(net.corda.core.crypto.SignatureScheme, java.math.BigInteger)/signatureScheme">signatureScheme</span><span class="symbol">:</span>&nbsp;<a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$deriveKeyPairFromEntropy(net.corda.core.crypto.SignatureScheme, java.math.BigInteger)/entropy">entropy</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html"><span class="identifier">BigInteger</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/KeyPair.html"><span class="identifier">KeyPair</span></a></code>
<p>Returns a key pair derived from the given <a href="http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html">BigInteger</a> entropy. This is useful for unit tests
and other cases where you want hard-coded private keys.
Currently, the following schemes are supported: <a href="-e-d-d-s-a_-e-d25519_-s-h-a512.html">EDDSA_ED25519_SHA512</a>, <a href="-e-c-d-s-a_-s-e-c-p256-r1_-s-h-a256.html">ECDSA_SECP256R1_SHA256</a> and <a href="-e-c-d-s-a_-s-e-c-p256-k1_-s-h-a256.html">ECDSA_SECP256K1_SHA256</a>.</p>
<code><span class="keyword">fun </span><span class="identifier">deriveKeyPairFromEntropy</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$deriveKeyPairFromEntropy(java.math.BigInteger)/entropy">entropy</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html"><span class="identifier">BigInteger</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/KeyPair.html"><span class="identifier">KeyPair</span></a></code>
<p>Returns a <a href="-d-e-f-a-u-l-t_-s-i-g-n-a-t-u-r-e_-s-c-h-e-m-e.html">DEFAULT_SIGNATURE_SCHEME</a> key pair derived from the given <a href="http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html">BigInteger</a> entropy.</p>
</td>
</tr>
<tr>
<td>
<p><a href="do-sign.html">doSign</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">doSign</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$doSign(java.security.PrivateKey, kotlin.ByteArray)/privateKey">privateKey</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html"><span class="identifier">PrivateKey</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doSign(java.security.PrivateKey, kotlin.ByteArray)/clearData">clearData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a></code>
<p>Generic way to sign <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html">ByteArray</a> data with a <a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html">PrivateKey</a>. Strategy on on identifying the actual signing scheme is based
on the <a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html">PrivateKey</a> type, but if the schemeCodeName is known, then better use
doSign(signatureScheme: String, privateKey: PrivateKey, clearData: ByteArray).</p>
<code><span class="keyword">fun </span><span class="identifier">doSign</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$doSign(kotlin.String, java.security.PrivateKey, kotlin.ByteArray)/schemeCodeName">schemeCodeName</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doSign(kotlin.String, java.security.PrivateKey, kotlin.ByteArray)/privateKey">privateKey</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html"><span class="identifier">PrivateKey</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doSign(kotlin.String, java.security.PrivateKey, kotlin.ByteArray)/clearData">clearData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a></code>
<p>Generic way to sign <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html">ByteArray</a> data with a <a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html">PrivateKey</a> and a known schemeCodeName <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html">String</a>.</p>
<code><span class="keyword">fun </span><span class="identifier">doSign</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$doSign(net.corda.core.crypto.SignatureScheme, java.security.PrivateKey, kotlin.ByteArray)/signatureScheme">signatureScheme</span><span class="symbol">:</span>&nbsp;<a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doSign(net.corda.core.crypto.SignatureScheme, java.security.PrivateKey, kotlin.ByteArray)/privateKey">privateKey</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html"><span class="identifier">PrivateKey</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doSign(net.corda.core.crypto.SignatureScheme, java.security.PrivateKey, kotlin.ByteArray)/clearData">clearData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a></code>
<p>Generic way to sign <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html">ByteArray</a> data with a <a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html">PrivateKey</a> and a known <a href="http://docs.oracle.com/javase/8/docs/api/java/security/Signature.html">Signature</a>.</p>
<code><span class="keyword">fun </span><span class="identifier">doSign</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$doSign(java.security.KeyPair, net.corda.core.crypto.SignableData)/keyPair">keyPair</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/KeyPair.html"><span class="identifier">KeyPair</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doSign(java.security.KeyPair, net.corda.core.crypto.SignableData)/signableData">signableData</span><span class="symbol">:</span>&nbsp;<a href="../-signable-data/index.html"><span class="identifier">SignableData</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="../-transaction-signature/index.html"><span class="identifier">TransactionSignature</span></a></code>
<p>Generic way to sign <a href="../-signable-data/index.html">SignableData</a> objects with a <a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html">PrivateKey</a>.
<a href="../-signable-data/index.html">SignableData</a> is a wrapper over the transaction's id (Merkle root) in order to attach extra information, such as
a timestamp or partial and blind signature indicators.</p>
</td>
</tr>
<tr>
<td>
<p><a href="do-verify.html">doVerify</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">doVerify</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(kotlin.String, java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/schemeCodeName">schemeCodeName</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(kotlin.String, java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/publicKey">publicKey</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(kotlin.String, java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/signatureData">signatureData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(kotlin.String, java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/clearData">clearData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code>
<p>Utility to simplify the act of verifying a digital signature.
It returns true if it succeeds, but it always throws an exception if verification fails.</p>
<code><span class="keyword">fun </span><span class="identifier">doVerify</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/publicKey">publicKey</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/signatureData">signatureData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/clearData">clearData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code>
<p>Utility to simplify the act of verifying a digital signature by identifying the signature scheme used from the input public key's type.
It returns true if it succeeds, but it always throws an exception if verification fails.
Strategy on identifying the actual signing scheme is based on the <a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html">PublicKey</a> type, but if the schemeCodeName is known,
then better use doVerify(schemeCodeName: String, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray).</p>
<code><span class="keyword">fun </span><span class="identifier">doVerify</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(net.corda.core.crypto.SignatureScheme, java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/signatureScheme">signatureScheme</span><span class="symbol">:</span>&nbsp;<a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(net.corda.core.crypto.SignatureScheme, java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/publicKey">publicKey</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(net.corda.core.crypto.SignatureScheme, java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/signatureData">signatureData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(net.corda.core.crypto.SignatureScheme, java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/clearData">clearData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code>
<p>Method to verify a digital signature.
It returns true if it succeeds, but it always throws an exception if verification fails.</p>
<code><span class="keyword">fun </span><span class="identifier">doVerify</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(net.corda.core.crypto.SecureHash, net.corda.core.crypto.TransactionSignature)/txId">txId</span><span class="symbol">:</span>&nbsp;<a href="../-secure-hash/index.html"><span class="identifier">SecureHash</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$doVerify(net.corda.core.crypto.SecureHash, net.corda.core.crypto.TransactionSignature)/transactionSignature">transactionSignature</span><span class="symbol">:</span>&nbsp;<a href="../-transaction-signature/index.html"><span class="identifier">TransactionSignature</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code>
<p>Utility to simplify the act of verifying a <a href="../-transaction-signature/index.html">TransactionSignature</a>.
It returns true if it succeeds, but it always throws an exception if verification fails.</p>
</td>
</tr>
<tr>
<td>
<p><a href="find-provider.html">findProvider</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">findProvider</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$findProvider(kotlin.String)/name">name</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/Provider.html"><span class="identifier">Provider</span></a></code></td>
</tr>
<tr>
<td>
<p><a href="find-signature-scheme.html">findSignatureScheme</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">findSignatureScheme</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$findSignatureScheme(org.bouncycastle.asn1.x509.AlgorithmIdentifier)/algorithm">algorithm</span><span class="symbol">:</span>&nbsp;<a href="http://www.bouncycastle.org/docs/docs1.5on/org/bouncycastle/asn1/x509/AlgorithmIdentifier.html"><span class="identifier">AlgorithmIdentifier</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a></code><code><span class="keyword">fun </span><span class="identifier">findSignatureScheme</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$findSignatureScheme(kotlin.Int)/schemeNumberID">schemeNumberID</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a></code>
<p>Find <a href="../-signature-scheme/index.html">SignatureScheme</a> by platform specific schemeNumberID.</p>
<code><span class="keyword">fun </span><span class="identifier">findSignatureScheme</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$findSignatureScheme(kotlin.String)/schemeCodeName">schemeCodeName</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a></code>
<p>Factory pattern to retrieve the corresponding <a href="../-signature-scheme/index.html">SignatureScheme</a> based on <a href="../-signature-scheme/scheme-code-name.html">SignatureScheme.schemeCodeName</a>.
This function is usually called by key generators and verify signature functions.
In case the input is not a key in the supportedSignatureSchemes map, null will be returned.</p>
<code><span class="keyword">fun </span><span class="identifier">findSignatureScheme</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$findSignatureScheme(java.security.PublicKey)/key">key</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a></code><br/>
<code><span class="keyword">fun </span><span class="identifier">findSignatureScheme</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$findSignatureScheme(java.security.PrivateKey)/key">key</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html"><span class="identifier">PrivateKey</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a></code>
<p>Retrieve the corresponding <a href="../-signature-scheme/index.html">SignatureScheme</a> based on the type of the input <a href="http://docs.oracle.com/javase/8/docs/api/java/security/Key.html">Key</a>.
This function is usually called when requiring to verify signatures and the signing schemes must be defined.
For the supported signature schemes see <a href="./index.html">Crypto</a>.</p>
</td>
</tr>
<tr>
<td>
<p><a href="generate-key-pair.html">generateKeyPair</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">generateKeyPair</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$generateKeyPair(kotlin.String)/schemeCodeName">schemeCodeName</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html"><span class="identifier">String</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/KeyPair.html"><span class="identifier">KeyPair</span></a></code>
<p>Utility to simplify the act of generating keys.
Normally, we don't expect other errors here, assuming that key generation parameters for every supported signature scheme have been unit-tested.</p>
<code><span class="keyword">fun </span><span class="identifier">generateKeyPair</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$generateKeyPair(net.corda.core.crypto.SignatureScheme)/signatureScheme">signatureScheme</span><span class="symbol">:</span>&nbsp;<a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a>&nbsp;<span class="symbol">=</span>&nbsp;DEFAULT_SIGNATURE_SCHEME<span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/KeyPair.html"><span class="identifier">KeyPair</span></a></code>
<p>Generate a <a href="http://docs.oracle.com/javase/8/docs/api/java/security/KeyPair.html">KeyPair</a> for the selected <a href="../-signature-scheme/index.html">SignatureScheme</a>.
Note that RSA is the sole algorithm initialized specifically by its supported keySize.</p>
</td>
</tr>
<tr>
<td>
<p><a href="is-supported-signature-scheme.html">isSupportedSignatureScheme</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">isSupportedSignatureScheme</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$isSupportedSignatureScheme(net.corda.core.crypto.SignatureScheme)/signatureScheme">signatureScheme</span><span class="symbol">:</span>&nbsp;<a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code>
<p>Check if the requested <a href="../-signature-scheme/index.html">SignatureScheme</a> is supported by the system.</p>
</td>
</tr>
<tr>
<td>
<p><a href="is-valid.html">isValid</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">isValid</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$isValid(net.corda.core.crypto.SecureHash, net.corda.core.crypto.TransactionSignature)/txId">txId</span><span class="symbol">:</span>&nbsp;<a href="../-secure-hash/index.html"><span class="identifier">SecureHash</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$isValid(net.corda.core.crypto.SecureHash, net.corda.core.crypto.TransactionSignature)/transactionSignature">transactionSignature</span><span class="symbol">:</span>&nbsp;<a href="../-transaction-signature/index.html"><span class="identifier">TransactionSignature</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code>
<p>Utility to simplify the act of verifying a digital signature by identifying the signature scheme used from the
input public key's type.
It returns true if it succeeds and false if not. In comparison to <a href="do-verify.html">doVerify</a> if the key and signature
do not match it returns false rather than throwing an exception. Normally you should use the function which throws,
as it avoids the risk of failing to test the result.</p>
<code><span class="keyword">fun </span><span class="identifier">isValid</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$isValid(java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/publicKey">publicKey</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$isValid(java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/signatureData">signatureData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$isValid(java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/clearData">clearData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code>
<p>Utility to simplify the act of verifying a digital signature by identifying the signature scheme used from the
input public key's type.
It returns true if it succeeds and false if not. In comparison to <a href="do-verify.html">doVerify</a> if the key and signature
do not match it returns false rather than throwing an exception. Normally you should use the function which throws,
as it avoids the risk of failing to test the result.
Use this method if the signature scheme is not a-priori known.</p>
<code><span class="keyword">fun </span><span class="identifier">isValid</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$isValid(net.corda.core.crypto.SignatureScheme, java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/signatureScheme">signatureScheme</span><span class="symbol">:</span>&nbsp;<a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$isValid(net.corda.core.crypto.SignatureScheme, java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/publicKey">publicKey</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$isValid(net.corda.core.crypto.SignatureScheme, java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/signatureData">signatureData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$isValid(net.corda.core.crypto.SignatureScheme, java.security.PublicKey, kotlin.ByteArray, kotlin.ByteArray)/clearData">clearData</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html"><span class="identifier">ByteArray</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code>
<p>Method to verify a digital signature. In comparison to <a href="do-verify.html">doVerify</a> if the key and signature
do not match it returns false rather than throwing an exception.
Use this method if the signature scheme type is a-priori unknown.</p>
</td>
</tr>
<tr>
<td>
<p><a href="public-key-on-curve.html">publicKeyOnCurve</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">publicKeyOnCurve</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$publicKeyOnCurve(net.corda.core.crypto.SignatureScheme, java.security.PublicKey)/signatureScheme">signatureScheme</span><span class="symbol">:</span>&nbsp;<a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.crypto.Crypto$publicKeyOnCurve(net.corda.core.crypto.SignatureScheme, java.security.PublicKey)/publicKey">publicKey</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code>
<p>Check if a point's coordinates are on the expected curve to avoid certain types of ECC attacks.
Point-at-infinity is not permitted as well.</p>
</td>
</tr>
<tr>
<td>
<p><a href="register-providers.html">registerProviders</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">registerProviders</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html"><span class="identifier">Unit</span></a></code>
<p>Method to force registering all <a href="./index.html">Crypto</a>-related cryptography <a href="http://docs.oracle.com/javase/8/docs/api/java/security/Provider.html">Provider</a>s.
It is recommended that it is invoked first thing on <code>main</code> functions, so the <a href="http://docs.oracle.com/javase/8/docs/api/java/security/Provider.html">Provider</a>s are in place before any
cryptographic operation is requested outside <a href="./index.html">Crypto</a> (i.e., SecureRandom, KeyStore, cert-path validation,
CRL &amp; CSR checks etc.).</p>
</td>
</tr>
<tr>
<td>
<p><a href="supported-signature-schemes.html">supportedSignatureSchemes</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">supportedSignatureSchemes</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html"><span class="identifier">List</span></a><span class="symbol">&lt;</span><a href="../-signature-scheme/index.html"><span class="identifier">SignatureScheme</span></a><span class="symbol">&gt;</span></code></td>
</tr>
<tr>
<td>
<p><a href="to-supported-private-key.html">toSupportedPrivateKey</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">toSupportedPrivateKey</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$toSupportedPrivateKey(java.security.PrivateKey)/key">key</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html"><span class="identifier">PrivateKey</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/PrivateKey.html"><span class="identifier">PrivateKey</span></a></code>
<p>Convert a private key to a supported implementation. This can be used to convert a SUN's EC key to an BC key.
This method is usually required to retrieve keys from JKS keystores that by default return SUN implementations.</p>
</td>
</tr>
<tr>
<td>
<p><a href="to-supported-public-key.html">toSupportedPublicKey</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">toSupportedPublicKey</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$toSupportedPublicKey(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)/key">key</span><span class="symbol">:</span>&nbsp;<a href="http://www.bouncycastle.org/docs/docs1.5on/org/bouncycastle/asn1/x509/SubjectPublicKeyInfo.html"><span class="identifier">SubjectPublicKeyInfo</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a></code>
<p>Convert a public key to a supported implementation.</p>
<code><span class="keyword">fun </span><span class="identifier">toSupportedPublicKey</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$toSupportedPublicKey(java.security.PublicKey)/key">key</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a></code>
<p>Convert a public key to a supported implementation. This can be used to convert a SUN's EC key to an BC key.
This method is usually required to retrieve a key (via its corresponding cert) from JKS keystores that by default
return SUN implementations.</p>
</td>
</tr>
<tr>
<td>
<p><a href="validate-public-key.html">validatePublicKey</a></p>
</td>
<td>
<code><span class="keyword">fun </span><span class="identifier">validatePublicKey</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.crypto.Crypto$validatePublicKey(java.security.PublicKey)/key">key</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/security/PublicKey.html"><span class="identifier">PublicKey</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html"><span class="identifier">Boolean</span></a></code>
<p>Check if a public key satisfies algorithm specs.
For instance, an ECC key should lie on the curve and not being point-at-infinity.</p>
</td>
</tr>
</tbody>
</table>
<h3>Extension Functions</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="../../net.corda.core.utilities/kotlin.-any/context-logger.html">contextLogger</a></p>
</td>
<td>
<code><span class="keyword">fun </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">.</span><span class="identifier">contextLogger</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Logger</span></code>
<p>When called from a companion object, returns the logger for the enclosing class.</p>
</td>
</tr>
</tbody>
</table>

<style>
    @import url("https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,500,600");
    #cookies-eu-banner {
        background-color: rgba(83, 88, 95, 0.9);
        border-radius: 3px;
        color: #fff;
        font-family: 'Source Sans Pro', sans-serif;
        font-size: 13px;
        font-weight: 400;
        left: 3px;
        position: fixed;
        padding: 6px;
        right: 3px;
        text-align: center;
        top: 100px;
        z-index: 1000;
    }
    
    #cookies-eu-banner h3,
    #cookies-eu-banner p {
        color: #fff;
        font-size: 18px;
        letter-spacing: 0;
    }
    
    #cookies-eu-banner h3 {
        font-size: 24px;
        font-style: normal;
        font-weight: 400;
        line-height: 1.2;
        margin: 9px 0 0;
        text-transform: uppercase;
    }
    
    #cookies-eu-banner p {
        margin-bottom: 10px;
        padding: 8px 36px 0;
        text-align: justify;
        line-height: 1.4em;
    }
    
    #cookies-eu-banner fieldset {
        min-width: 0;
        padding: 0;
        margin: 0;
        border: 0;
    }
    
    #cookies-eu-banner legend {
        color: inherit;
        display: block;
        font-size: 18px;
        line-height: inherit;
        max-width: 100%;
        margin-bottom: 16px;
        padding: 0;
        white-space: normal;
        width: 100%;
    }
    
    #cookies-eu-banner a {
        color: #62AAF1;
    }
    
    #cookies-eu-banner .cookies-button-group {
        display: flex;
        justify-content: center;
    }
    
    #cookies-eu-accept,
    #cookies-eu-accept-all {
        background-color: #ec1d24;
        border: none;
        border-radius: 6px;
        color: #fff;
        font-size: 12px;
        font-weight: 600;
        margin: 0 10px 10px;
        max-height: 40px;
        height: 40px;
        line-height: 1.1;
        text-decoration: none;
        width: 150px;
    }
    
    .cookies-checkbox {
        display: inline-block;
        margin: 5px 10px;
    }
    
    .cookies-checkbox label {
        font-size: 16px;
        margin-left: 3px;
    }
    
    @media screen and (min-width: 768px) {
        #cookies-eu-banner {
            bottom: 5px;
            top: inherit;
        }
        #cookies-eu-accept,
        #cookies-eu-accept-all {
            font-size: 14px;
        }
    }
</style>
<div id="cookies-eu-banner" style="display: none;">
    <h3 style="text-transform:none">Your privacy</h3>
    <div class='cookie-flex'>
        <p>
            We use cookies to improve your experience on our site, and to help us understand how people use our documentation. For more detailed information, see our <a href="https://www.r3.com/privacy-policy/">privacy policy</a> and <a href="#">cookie declaration</a>.
        </p>
        <form id='cookie-consent-form'>
            <fieldset>
                <legend>
                    Please select from the following options to continue to our site.
                </legend>
                <div class='cookies-button-group'>
                    <button id="cookies-eu-accept" type="button">
                      Allow cookies selected
                    </button>
                    <button id="cookies-eu-accept-all" type="button">
                      Allow all cookies
                    </button>
                    <span class='cookies-checkbox'>
                      <input
                      type="checkbox"
                      id="necessary"
                      name="necessary"
                      autocomplete="off"
                      checked
                      disabled />
                        <input
                        name="necessary"
                        type="hidden"
                        value="on"/>
                        <label for="necessary">Necessary</label>
                    </span>
                    <span class='cookies-checkbox'>
                      <input
                      type="checkbox"
                      id="preferences"
                      name="preferences"
                      autocomplete="off" />
                      <label for="preferences">Preferences</label>
                    </span>
                    <span class='cookies-checkbox'>
                      <input
                      type="checkbox"
                      id="statistics"
                      name="statistics"
                      autocomplete="off" />
                      <label for="statistics">Statistics</label>
                    </span>
                    <span class='cookies-checkbox'>
                      <input
                      type="checkbox"
                      id="marketing"
                      name="marketing"
                      autocomplete="off" />
                      <label for="marketing">Marketing</label>
                    </span>
                </div>
            </fieldset>
        </form>
    </div>
</div>
<script class='api-keys'>
    var gaKey = 'UA-87760032-1';
    var algolia_appId = "UX2KMUWFAL";
    var algolia_apiKey = "1fe3367db02689b4aeebc59efad5abaf";
    var algolia_index = "docs.corda.net";
</script>
<script class='cookies-eu-banner'>
    ! function(root, factory) {
        "use strict";
        "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? module.exports = factory() : root.CookiesEuBanner = factory()
    }(window, function() {
        "use strict";
        var document = window.document,
            CookiesEuBanner = function(launchFunction, waitAccept, useLocalStorage, undefined) {
                if (!(this instanceof CookiesEuBanner)) return new CookiesEuBanner(launchFunction);
                this.cookieTimeout = 33696e6, this.bots = /bot|crawler|spider|crawling/i, this.cookieName = "hasConsent", this.trackingCookiesNames = ["__utma", "__utmb", "__utmc", "__utmt", "__utmv", "__utmz", "_ga", "_gat", "_gid"], this.launchFunction = launchFunction, this.waitAccept = waitAccept || !1, this.useLocalStorage = useLocalStorage || !1, this.init()
            };
        return CookiesEuBanner.prototype = {
            init: function() {
                var isBot = this.bots.test(navigator.userAgent);
                navigator.doNotTrack || navigator.msDoNotTrack || window.doNotTrack;
                return isBot || !1 === this.hasConsent() ? (this.removeBanner(0), !1) : !0 === this.hasConsent() ? (this.launchFunction(), !0) : (this.showBanner(), void(this.waitAccept || this.setConsent(!0)))
            },
            showBanner: function() {
                var _this = this,
                    getElementById = document.getElementById.bind(document),
                    banner = getElementById("cookies-eu-banner"),
                    rejectButton = getElementById("cookies-eu-reject"),
                    acceptButton = getElementById("cookies-eu-accept"),
                    moreLink = getElementById("cookies-eu-more"),
                    waitRemove = void 0 === banner.dataset.waitRemove ? 0 : parseInt(banner.dataset.waitRemove),
                    addClickListener = this.addClickListener,
                    removeBanner = _this.removeBanner.bind(_this, waitRemove);
                banner.style.display = "block", moreLink && addClickListener(moreLink, function() {
                    _this.deleteCookie(_this.cookieName)
                }), acceptButton && addClickListener(acceptButton, function() {
                    removeBanner(), _this.setConsent(!0), _this.launchFunction()
                }), rejectButton && addClickListener(rejectButton, function() {
                    removeBanner(), _this.setConsent(!1), _this.trackingCookiesNames.map(_this.deleteCookie)
                })
            },
            setConsent: function(consent) {
                if (this.useLocalStorage) return localStorage.setItem(this.cookieName, consent);
                this.setCookie(this.cookieName, consent)
            },
            hasConsent: function() {
                function isCookieSetTo(value) {
                    return -1 < document.cookie.indexOf(cookieName + "=" + value) || localStorage.getItem(cookieName) === value
                }
                var cookieName = this.cookieName;
                return !!isCookieSetTo("true") || !isCookieSetTo("false") && null
            },
            setCookie: function(name, value) {
                var date = new Date;
                date.setTime(date.getTime() + this.cookieTimeout), document.cookie = name + "=" + value + ";SameSite=Strict;expires=" + date.toGMTString() + ";path=/"
            },
            deleteCookie: function(name) {
                var hostname = document.location.hostname.replace(/^www\./, ""),
                    commonSuffix = "; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/";
                document.cookie = name + "=; domain=." + hostname + commonSuffix, document.cookie = name + "=" + commonSuffix
            },
            addClickListener: function(DOMElement, callback) {
                if (DOMElement.attachEvent) return DOMElement.attachEvent("onclick", callback);
                DOMElement.addEventListener("click", callback)
            },
            removeBanner: function(wait) {
                setTimeout(function() {
                    var banner = document.getElementById("cookies-eu-banner");
                    banner && banner.parentNode && banner.parentNode.removeChild(banner)
                }, wait)
            }
        }, CookiesEuBanner
    });
</script>
<script class='google-analytics'>
    function googleAnalytics() {
        var i, s, o, r, a, m;
        i = window, s = document, o = "script", r = "ga", i.GoogleAnalyticsObject = r, i.ga = i.ga || function() {
            (i.ga.q = i.ga.q || []).push(arguments)
        }, i.ga.l = +new Date, a = s.createElement(o), m = s.getElementsByTagName(o)[0], a.async = 1, a.src = "//www.google-analytics.com/analytics.js", m.parentNode.insertBefore(a, m), window.ga("create", "UA-87760032-1", "auto"), window.ga("send", "pageview")
    }
</script>
<script class='docSearchInit'>
    function docSearchInit() {
        var algoliaOptions;
        document.querySelector("#search-input") && (algoliaOptions = {
            hitsPerPage: 5,
            facetFilters: facetFilters
        }, /404.html/.test(window.location.pathname) && delete algoliaOptions.facetFilters, window.docsearch({
            appId: algolia_appId,
            apiKey: algolia_apiKey,
            indexName: algolia_index,
            inputSelector: "#search-input",
            algoliaOptions: algoliaOptions
        }))
    }
</script>
<script class='corda-cookie-banner'>
    const docsearchLoad = (resolve, reject) => {
        const script = document.createElement('script');
        document.body.appendChild(script);
        script.onload = resolve;
        script.onerror = reject;
        script.async = true;
        script.src = "https://cdn.jsdelivr.net/npm/docsearch.js@2.6.3/dist/cdn/docsearch.min.js";
    };

    class DocsiteCookies {
        constructor() {
            this.name = 'corda_cookie';
            this.cookiesAccepted = {
                set: true,
                necessary: true,
                preferences: false,
                statistics: false,
                marketing: false
            };
            this.form = document.querySelector('#cookie-consent-form');
            this.handleAllCookies();

            new CookiesEuBanner(() => {
                this.cookieBanner();
            }, true);
        }

        handleAllCookies() {
            const acceptButton = document.querySelector('#cookies-eu-accept');
            const allCookiesButton = document.querySelector('#cookies-eu-accept-all');

            allCookiesButton.addEventListener('click', e => {
                e.preventDefault();
                this.allowAllCookies(this.form);
                acceptButton.click();
            });
        }

        cookieBanner() {
            if (!this.checkConsent()) {
                this.formToCookie(this.name, this.form);
                this.setAdditionalServices();
            } else {
                this.setAdditionalServices();
            }
        }

        allowAllCookies(form) {
            let cookiePreferences = form.querySelectorAll('.cookies-checkbox');
            for (let cookie of cookiePreferences) {
                cookie.querySelector('input').checked = true;
            }
        }

        formToCookie(name, form) {
            const thirteenMonthsInMils = 31104000000;

            let date = new Date();
            date.setTime(date.getTime() + thirteenMonthsInMils);

            let formData = new FormData(form);
            for (var pair of formData.entries()) {
                switch (pair[0]) {
                    case "necessary":
                        this.cookiesAccepted.necessary = (pair[1] === 'on') ?
                            true :
                            false;
                        break;
                    case "preferences":
                        this.cookiesAccepted.preferences = (pair[1] === 'on') ?
                            true :
                            false;
                        break;
                    case "statistics":
                        this.cookiesAccepted.statistics = (pair[1] === 'on') ?
                            true :
                            false;
                        break;
                    case "marketing":
                        this.cookiesAccepted.marketing = (pair[1] === 'on') ?
                            true :
                            false;
                        break;
                    default:
                        break;
                }
            }
            let cookieValue = JSON.stringify(this.cookiesAccepted);

            document.cookie = `${name}=${cookieValue};SameSite=Strict;expires=${date.toGMTString()};path=/`;
        }

        checkConsent() {
            let cookieName = this.name;
            let cookieValue = this.getCookie(cookieName);

            if (cookieValue) {
                if (cookieValue.set === true) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }

        getCookie(name) {
            let value = "; " + document.cookie;
            let parts = value.split("; " + name + "=");
            let cValue = "";

            if (parts.length == 2) {
                cValue = parts.pop().split(";").shift();
            }

            if (hasJsonStructure(cValue)) {
                return JSON.parse(cValue);
            } else {
                return cValue;
            }
        }

        setAdditionalServices() {
            let cookieConsent = this.getCookie(this.name);
            for (let [key, value] of Object.entries(cookieConsent)) {
                if (key === 'necessary' && value === true) {
                    new Promise(docsearchLoad)
                        .then(() => {
                            docSearchInit();
                        })
                        .catch(err => console.log(err));
                }
                if (key === 'statistics' && value === true) {
                    googleAnalytics();
                }
            }
        }
    }

    function hasJsonStructure(str) {
        if (typeof str !== 'string') return false;
        try {
            const result = JSON.parse(str);
            const type = Object.prototype.toString.call(result);
            return type === '[object Object]' ||
                type === '[object Array]';
        } catch (err) {
            return false;
        }
    }
</script>
<script class='initialise'>
    new DocsiteCookies();
</script>
</body>
</HTML>
