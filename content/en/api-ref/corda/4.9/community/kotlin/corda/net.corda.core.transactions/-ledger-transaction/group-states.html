<HTML>
<HEAD>
<meta charset="UTF-8">
<title>LedgerTransaction.groupStates - corda</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">corda</a>&nbsp;/&nbsp;<a href="../index.html">net.corda.core.transactions</a>&nbsp;/&nbsp;<a href="index.html">LedgerTransaction</a>&nbsp;/&nbsp;<a href="./group-states.html">groupStates</a><br/>
<br/>
<h1>groupStates</h1>
<a name="net.corda.core.transactions.LedgerTransaction$groupStates(java.lang.Class((net.corda.core.transactions.LedgerTransaction.groupStates.T)), kotlin.Function1((net.corda.core.transactions.LedgerTransaction.groupStates.T, net.corda.core.transactions.LedgerTransaction.groupStates.K)))"></a>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../../net.corda.core.contracts/-contract-state/index.html"><span class="identifier">ContractState</span></a><span class="symbol">, </span><span class="identifier">K</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span> <span class="identifier">groupStates</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.transactions.LedgerTransaction$groupStates(java.lang.Class((net.corda.core.transactions.LedgerTransaction.groupStates.T)), kotlin.Function1((net.corda.core.transactions.LedgerTransaction.groupStates.T, net.corda.core.transactions.LedgerTransaction.groupStates.K)))/ofType">ofType</span><span class="symbol">:</span>&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html"><span class="identifier">Class</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="net.corda.core.transactions.LedgerTransaction$groupStates(java.lang.Class((net.corda.core.transactions.LedgerTransaction.groupStates.T)), kotlin.Function1((net.corda.core.transactions.LedgerTransaction.groupStates.T, net.corda.core.transactions.LedgerTransaction.groupStates.K)))/selector">selector</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><span class="identifier">T</span><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">K</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html"><span class="identifier">List</span></a><span class="symbol">&lt;</span><span class="identifier">InOutGroup</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">,</span>&nbsp;<span class="identifier">K</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code>
<p>Given a type and a function that returns a grouping key, associates inputs and outputs together so that they
can be processed as one. The grouping key is any arbitrary object that can act as a map key (so must implement
equals and hashCode).</p>
<p>The purpose of this function is to simplify the writing of verification logic for transactions that may contain
similar but unrelated state evolutions which need to be checked independently. Consider a transaction that
simultaneously moves both dollars and euros (e.g. is an atomic FX trade). There may be multiple dollar inputs and
multiple dollar outputs, depending on things like how fragmented the owner's vault is and whether various privacy
techniques are in use. The quantity of dollars on the output side must sum to the same as on the input side, to
ensure no money is being lost track of. This summation and checking must be repeated independently for each
currency. To solve this, you would use groupStates with a type of Cash.State and a selector that returns the
currency field: the resulting list can then be iterated over to perform the per-currency calculation.</p>
<a name="net.corda.core.transactions.LedgerTransaction$groupStates(kotlin.Function1((net.corda.core.transactions.LedgerTransaction.groupStates.T, net.corda.core.transactions.LedgerTransaction.groupStates.K)))"></a>
<code><span class="keyword">inline</span> <span class="keyword">fun </span><span class="symbol">&lt;</span><span class="keyword">reified</span>&nbsp;<span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../../net.corda.core.contracts/-contract-state/index.html"><span class="identifier">ContractState</span></a><span class="symbol">, </span><span class="identifier">K</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span> <span class="identifier">groupStates</span><span class="symbol">(</span><span class="keyword">noinline</span> <span class="identifier" id="net.corda.core.transactions.LedgerTransaction$groupStates(kotlin.Function1((net.corda.core.transactions.LedgerTransaction.groupStates.T, net.corda.core.transactions.LedgerTransaction.groupStates.K)))/selector">selector</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><span class="identifier">T</span><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">K</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html"><span class="identifier">List</span></a><span class="symbol">&lt;</span><span class="identifier">InOutGroup</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">,</span>&nbsp;<span class="identifier">K</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code>
<p>See the documentation for the reflection-based version of <a href="./group-states.html">groupStates</a></p>
</BODY>
</HTML>
