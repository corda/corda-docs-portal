<HTML>
<HEAD>
<meta charset="UTF-8">
<title>TransactionState.encumbrance - ledger</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">ledger</a>&nbsp;/&nbsp;<a href="../index.html">net.corda.v5.ledger.contracts</a>&nbsp;/&nbsp;<a href="index.html">TransactionState</a>&nbsp;/&nbsp;<a href="./encumbrance.html">encumbrance</a><br/>
<br/>
<h1>encumbrance</h1>
<a name="net.corda.v5.ledger.contracts.TransactionState$encumbrance"></a>
<code><span class="keyword">val </span><span class="identifier">encumbrance</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html"><span class="identifier">Int</span></a><span class="symbol">?</span></code>
<p>All contract states may be <em>encumbered</em> by up to one other state. The encumbrance state, if present, forces additional
controls over the encumbered state, since the platform checks that the encumbrance state is present as an input in the same transaction
that consumes the encumbered state, and the contract code and rules of the encumbrance state will also be verified during the execution
of the transaction. For example, a cash contract state could be encumbered with a time-lock contract state; the cash state is then only
processable in a transaction that verifies that the time specified in the encumbrance time-lock has passed.</p>
<p>The encumbered state refers to another by index, and the referred encumbrance state is an output state in a particular position on the
same transaction that created the encumbered state. An alternative implementation would be encumbering by reference to a <a href="../-state-ref/index.html">StateRef</a>,
which would allow the specification of encumbrance by a state created in a prior transaction.</p>
<p>Note that an encumbered state that is being consumed must have its encumbrance consumed in the same transaction, otherwise the
transaction is not valid.</p>
</BODY>
</HTML>
