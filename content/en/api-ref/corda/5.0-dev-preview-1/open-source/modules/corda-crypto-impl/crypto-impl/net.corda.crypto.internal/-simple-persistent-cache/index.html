<HTML>
<HEAD>
<meta charset="UTF-8">
<title>SimplePersistentCache - crypto-impl</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">crypto-impl</a>&nbsp;/&nbsp;<a href="../index.html">net.corda.crypto.internal</a>&nbsp;/&nbsp;<a href="./index.html">SimplePersistentCache</a><br/>
<br/>
<h1>SimplePersistentCache</h1>
<code><span class="keyword">interface </span><span class="identifier">SimplePersistentCache</span><span class="symbol">&lt;</span><span class="identifier">V</span><span class="symbol">, </span><span class="identifier">E</span><span class="symbol">&gt;</span></code>
<p>Defines a simplified caching layer on top of an <em>append-only</em> persistence.
The cached and persistence items are different, the mutator defines the shape of the cached item
based on the persistent item.
It's expected that the implementation is race condition with different instances safe.</p>
<h3>Parameters</h3>
<p><a name="V"></a>
<code>V</code> - : the cached item type</p>
<p><a name="E"></a>
<code>E</code> - : the persistent entity type</p>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<h4><a href="get.html">get</a></h4>
</td>
<td>
<p>Returns the value associated with the key, first loading that value from the storage if necessary and mutating it
or null if the value is not found.</p>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">get</span><span class="symbol">(</span><span class="identifier" id="net.corda.crypto.internal.SimplePersistentCache$get(kotlin.Any, kotlin.Function1((net.corda.crypto.internal.SimplePersistentCache.E, net.corda.crypto.internal.SimplePersistentCache.V)))/key">key</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.crypto.internal.SimplePersistentCache$get(kotlin.Any, kotlin.Function1((net.corda.crypto.internal.SimplePersistentCache.E, net.corda.crypto.internal.SimplePersistentCache.V)))/mutator">mutator</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><span class="identifier">entity</span><span class="symbol">:</span>&nbsp;<span class="identifier">E</span><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">V</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">V</span><span class="symbol">?</span></code></td>
</tr>
<tr>
<td>
<h4><a href="put.html">put</a></h4>
</td>
<td>
<p>Persist the specified value and associates mutated value of it with the specified key in this map (in that order).
If the underlying storage previously contained a value for the key, the behaviour is unpredictable
and most likely will throw an error from the underlying storage.</p>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">put</span><span class="symbol">(</span><span class="identifier" id="net.corda.crypto.internal.SimplePersistentCache$put(kotlin.Any, net.corda.crypto.internal.SimplePersistentCache.E, kotlin.Function1((net.corda.crypto.internal.SimplePersistentCache.E, net.corda.crypto.internal.SimplePersistentCache.V)))/key">key</span><span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.crypto.internal.SimplePersistentCache$put(kotlin.Any, net.corda.crypto.internal.SimplePersistentCache.E, kotlin.Function1((net.corda.crypto.internal.SimplePersistentCache.E, net.corda.crypto.internal.SimplePersistentCache.V)))/entity">entity</span><span class="symbol">:</span>&nbsp;<span class="identifier">E</span><span class="symbol">, </span><span class="identifier" id="net.corda.crypto.internal.SimplePersistentCache$put(kotlin.Any, net.corda.crypto.internal.SimplePersistentCache.E, kotlin.Function1((net.corda.crypto.internal.SimplePersistentCache.E, net.corda.crypto.internal.SimplePersistentCache.V)))/mutator">mutator</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><span class="identifier">entity</span><span class="symbol">:</span>&nbsp;<span class="identifier">E</span><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">V</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">V</span></code></td>
</tr>
</tbody>
</table>
<h3>Inheritors</h3>
<table>
<tbody>
<tr>
<td>
<h4><a href="../-simple-persistent-cache-impl/index.html">SimplePersistentCacheImpl</a></h4>
</td>
<td>
<p>Implements a simplified caching layer on top of an <em>append-only</em> table accessed via Hibernate mapping.
Note that if the same key is stored twice, typically this will result in a duplicate insert if this is racing
with another transaction in different instance which would be prevented by the primary key constrain.
The implementation is race condition with different instance safe.</p>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">SimplePersistentCacheImpl</span><span class="symbol">&lt;</span><span class="identifier">V</span><span class="symbol">, </span><span class="identifier">E</span><span class="symbol">&gt;</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="./index.html"><span class="identifier">SimplePersistentCache</span></a><span class="symbol">&lt;</span><span class="identifier">V</span><span class="symbol">,</span>&nbsp;<span class="identifier">E</span><span class="symbol">&gt;</span><span class="symbol">, </span><a href="https://docs.oracle.com/javase/6/docs/api/java/lang/AutoCloseable.html"><span class="identifier">AutoCloseable</span></a></code></td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
